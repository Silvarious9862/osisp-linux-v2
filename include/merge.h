#ifndef MERGE_H
#define MERGE_H

#include <pthread.h>
#include "index.h"  // Определение структуры struct index_s

/**
 * merge_data – структура для хранения данных, необходимых для слияния отсортированных блоков.
 *
 * Поля:
 *  - records: указатель на массив отсортированных индексных записей (начало отображённой области);
 *  - block_size: текущий размер блока (в записях);
 *  - num_blocks: текущее количество блоков, оставшихся для слияния;
 *  - mutex: (при необходимости) мьютекс для динамического распределения блоков (в данном варианте не используется);
 *  - barrier: барьер для синхронизации потоков между фазами слияния.
 */
typedef struct {
    struct index_s *records;
    size_t block_size;    // размер одного блока (в записях)
    int num_blocks;       // текущее количество блоков
    pthread_mutex_t mutex;   // резерв для возможного динамического распределения (не используется в этом упрощённом варианте)
    pthread_barrier_t barrier;  // синхронизация фаз слияния
} merge_data;

/**
 * merge_thread_arg – аргументы, передаваемые каждому потоку, выполняющему слияние.
 *
 * Поля:
 *  - thread_id: уникальный идентификатор потока;
 *  - num_threads: общее число потоков, участвующих в слиянии;
 *  - md: указатель на общую структуру merge_data.
 */
typedef struct {
    int thread_id;
    int num_threads;
    merge_data *md;
} merge_thread_arg;

/**
 * merge_init() – инициализирует структуру merge_data для этапа слияния.
 *
 * @md: указатель на структуру merge_data;
 * @records: указатель на массив отсортированных записей (начало области после заголовка),
 * @block_size: начальный размер блока (количество записей в блоке, полученный после сортировки),
 * @num_blocks: общее число блоков (должно быть степенью двойки),
 * @num_threads: число потоков, участвующих в слиянии (для установки количества участников барьера).
 *
 * Возвращает 0 при успехе, -1 при ошибке.
 */
int merge_init(merge_data *md, struct index_s *records, size_t block_size, int num_blocks, int num_threads);

/**
 * merge_two_sorted_blocks() – сливает два отсортированных блока.
 *
 * @block1: указатель на первый блок, в который будет записан результат слияния;
 * @n1: число записей в первом блоке,
 * @block2: указатель на второй блок;
 * @n2: число записей во втором блоке.
 *
 * Функция использует временный массив для объединения двух частей и копирует результат в block1.
 */
void merge_two_sorted_blocks(struct index_s *block1, size_t n1, struct index_s *block2, size_t n2);

/**
 * merge_blocks_phase() – функция, которую выполняют потоки для слияния отсортированных блоков.
 *
 * Каждый поток по очереди (в зависимости от своего идентификатора) сливает пару блоков:
 * блоки с номерами 2*i и 2*i+1 для i, равного идентификатору потока (если такой парный набор существует).
 * Если для потока нет пары для слияния, он просто ждёт на барьере.
 * После слияния обновляется общее число блоков (оно уменьшается вдвое, с учетом нечетного числа блоков),
 * а размер блока удваивается.
 *
 * @arg: указатель на структуру merge_thread_arg.
 */
void *merge_blocks_phase(void *arg);

#endif // MERGE_H
